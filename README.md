# Symfony Vuetified

A base project for creating a [Symfony](https://symfony.com/) application that uses
[Vuetify](https://vuetifyjs.com/en/) as frontend, while making it easy to pass serverside data.

The composer.json of this project is a copy of the Symfony 5.x
[symfony/website-skeleton](https://github.com/symfony/website-skeleton)
and the addition of `"symfony/webpack-encore-bundle": "*"`. 

# Getting started

Assuming you run a server with php7.2.5+ (or 8.0+), mysql, composer, yarn (or npm) and required modules:

1. Checkout project
2. Run `composer install`
3. Run`./init-project.sh`    
   You'll see Errors about missing packages when the script is trying to run Webpack.
   The script will try to install missing packages automatically.
   If this isn't working, then check the last manual step.

Follow the manual steps below if you're running into trouble.

## Manual steps (only needed if automatic setup failed)

3. Make changes in `webpack.config.js` file to enable Typescript, Sass, Vue and Vuetify:
```js
const VuetifyLoaderPlugin = require('vuetify-loader/lib/plugin');
const WebTypesPlugin = require('./assets/plugins/WebTypesPlugin');

// [...]

Encore.
    
    // [...]

    .enableSassLoader()
    .enableTypeScriptLoader()
    .enableVueLoader(() => {}, {
        useJsx: true
    })
    .addPlugin(new VuetifyLoaderPlugin())
    .addPlugin(new WebTypesPlugin())

    // [...]
```
(more info: https://symfony.com/doc/current/frontend/encore/vuejs.html#jsx-support)

4. Add the following line to your `assets/app.js` file:
```js
import './main';
```
5. Run `yarn add vuetify`
6. Run `yarn add sass deepmerge vuetify-loader vue-property-decorator vue-class-component -D`
7. Run `yarn install`
8. Add `"web-types": "web-types.json"` to the root-object in `packages.json`  
    This will help PhpStorm (and possibly other IDE's) recognize global vue objects. The `web-types.json` is a file
    containing info about the vue-components that will be generated by the `WebTypesPlugin` once you run webpack.
9. Run `yarn dev`
    Add the additional packages that you'll see in the Error(s).
    Repeat this step until no further packages are required.

# Concept/usage

This base projects aims to make it easy to use Twig and Vue without resorting to API's or `data-` attributes in HTML.

## Global vue object

The basic concept is that you can use a global vue object.
This object will be used for creating the vue-instance.

```vue
{% extends 'base.html.twig' %}
{% block body %}
    <p>
        @{ seconds } seconds have passed.
    </p>
{% endblock %}
{% block script %}
    <script>
        vue = {
            data: () => ({
                seconds: 0,
            }),
            mounted() {
                setInterval(() => {
                    this.seconds++;
                }, 1000);
            },
        };
    </script>
{% endblock %}
```

> **Note:** Vue and Twig both use `{{` and `}}` delimiters by default, so here `@{` and `}` are used instead for Vue.
> You can specify different delimiters if you want, but avoid using `${` 
> like [Symfony's example](https://symfony.com/doc/5.2/frontend/encore/vuejs.html#using-vue-inside-twig-templates):
> When you use `${something}` this is parsed as javascript variable when used inside ticks ( \` ), which is needed sometimes.

## Passing data (`vue_data`)

When passing data, youâ€™ll often need to do things like below:

```vue
{% block script %}
    <script>
        vue = {
            data: () => ({
                someObject: {{ someObject | json_encode | raw }},
                anotherObject: {{ anotherObject | json_encode | raw }},
            })
        }
    </script>
{% endblock %}
```

If you need to pass server data to vue, you can use `vue_data` instead:

```vue
{% block body %}
    {{ vue_data('someObject', someObject) }}
    {{ vue_data('anotherObject', anotherObject) }}
    <div v-if="someObject && anotherObject">
        This tekst is only shown if both objects have a value.
    </div>
{% endblock %}
```

Data added this way will be json encoded and merged with the global vue object.

## Global observable (`$store` and `vue_store`)

In addition to adding data to the vue-instance, data can be added to the vue $store observable, making
data available to all vue components.
```vue
{% block body %}
    {{ vue_store('someObject', someObject) }}
    {{ vue_store('anotherObject', anotherObject) }}
    <div v-if="$store.someObject && $store.anotherObject">
        This tekst is only shown if both objects have a value.
    </div>
{% endblock %}
```

## Global vue components
Vue-components aren't global by default, so they can't be used in Twig.
By using the `.global.vue` or `.g.vue` extension instead of just `.vue` the
component will be made global, allowing you to use it inside Twig.

> Autocompletion in PhpStorm doesn't seem to work (yet?) for global components.
> This project lets webpack create a `web-types.json` to define references for the global components.
> It won't give autocompletion for props/slots/events, but at least you'll have autocompletion
> for the component name and reference to the file.

# Using Fetch

Because dynamic vue components can be rendered at runtime, the same principles can be used with `fetch` and load the
response in a component.

This project includes a FetchComponent that makes it really easy:
```vue
<fetch-component url="/url-to-controller-action"></fetch-component>
```

The `base.html.twig` file in this project checks if a fetch was used to choose the suitable file to extend:
if you're using fetch, only a template and the script will be loaded. Otherwise, the entire page is loaded.

> **Note:** this component requires loading the fetched javascript. 
> Fetching a page that defines variables/constants that were defined already will result in javascript-errors.
> Therefore, this project uses `window` to put global objects (like the global `vue`) into.  
> The fetchComponents specifically takes the global objects vue, vueData, vueStoreData into account by clearing these
> objects before fetching new content.

# Symfony form as Vue component

Using form-functions in Twig or form_themes to create a Vuetify-form is a pain (at least in my experience),
so instead this project uses a `FormVue` class that json_encodes Symfony's `FormView`.
This json is passed to the vue component, `vue_form`, to have the entire form render by using Vue.

Example Usage:
```vue
{% block body %}
    {{ vue_data('form', form) }} {# json_encoding of the form is handled by the vueDataStorage #}
    <vue-form :form="form"></vue-form>
{% endblock %}
```

Just like you could in Twig, you can take full control and render parts individually. It takes some getting used to
it, because obviously Vue works differently, but it is quite powerful. 

There are several ways you can use to render different parts of your form:

**1) Using form-widget and full object paths**

```vue
<vue-form :form="form">
    <form-widget :form="form.children.name"></form-widget>
    <form-widget :form="form.children.email"></form-widget>
</vue-form>
```
**2) Using the `children` parameter provided by the default slot:**
```vue
<vue-form :form="form" v-slot="{ children }">
    <form-widget v-for="(child, key) of children" :key="key" :form="child"></form-widget>
</vue-form>
```
(this approach can be mixed with the first approach)  

**3) Using the child form names of default slot:**
```vue
<vue-form :form="form" v-slot="{ name, email }">
    <form-widget :form="name"></form-widget>
    <form-widget :form="email"></form-widget>
</vue-form>
```
(this approach can be mixed with the previous approaches)  

**4) Using subform slots for the children:**
```vue
<vue-form :form="form">
    <template v-slot:subform_name="{ subform }">
        <form-widget :form="subform"></form-widget>
    </template>
    <!-- email is still rendered by the vue-form -->
</vue-form>
```
The `subform_` prefix is being used here to make sure slots won't overlap (e.g. when a field is called 'default').

Subform slots are defined within the default slot, so this approach cannot be combined with the previous ones.
Doing so would result in these subform slots being ignored by vue.

Using subform slots can be useful when you want to make changes for specific fields but don't need to change
the rendering (or order) of other fields.


**5) Using specific component types:**
```vue
<vue-form :form="form" v-slot="{ name, email }">
    <text-type :form="name"></text-type>
    <textarea-type :form="email"></textarea-type>
</vue-form>
```
Here the text-type and texteara-types components are used despite the 'type' that is provided by
the serverside form definition.

This last option can be useful when you want to use slots that are defined by Vuetify, since the
form-widget cannot cascade all slots (this would conflict with the default-slot).

## Custom form-type-components

To create a custom form-type, you should have a look at the `/assets/components/Form` directory.
Most of the logic you need is put in the `FormTypeMixin`, so you probably want to extend that to have some stuff taken
care of. 

For example, if you want to create a wysiwyg text-editor using quill, you could create a EditorType:
```vue
<template>
    <div class="text-editor-type">
        <!-- use a hidden field to use when submitting the form -->
        <input type="hidden" :name="form.vars.full_name" :value="form.vars.data" />
        <quill-editor
            ref="myTextEditor"
            v-model="form.vars.data"
        />
    </div>
</template>

<script lang="ts">
    import {Component, Mixins} from 'vue-property-decorator';
    import FormWidgetMixin from "./FormWidgetMixin.ts";
    import quillEditor from 'vue-quill-editor';
    
    @Component
    export default class EditorType extends Mixins(FormWidgetMixin) {
        created() {
            // do stuff like applying settings to the editor...
        }
    }
</script>
```

Now you could use this component directly by using something like `<editor-type :form="form"></editor-type>`.


The block_prefixes are used to determine what component should be used for each individual field.
By setting a `block_prefix` in your FormType, you can specify a different component that you want to use for your
field. So within your form type class, you can use something like this:
```php
public function buildForm(FormBuilderInterface $builder, array $options): void
{
    $builder->add('text', null, [
        'label' => 'Text',
        'block_prefix' => 'EditorType',
    ]);
}
```